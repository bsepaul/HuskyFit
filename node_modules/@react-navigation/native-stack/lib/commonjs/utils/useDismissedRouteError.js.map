{"version":3,"names":["useInvalidPreventRemoveError","state","nextDismissedKey","setNextDismissedKey","React","useState","dismissedRouteName","routes","find","route","key","name","useEffect","message","console","error"],"sources":["useDismissedRouteError.tsx"],"sourcesContent":["import type {\n  ParamListBase,\n  StackNavigationState,\n} from '@react-navigation/native';\nimport * as React from 'react';\n\nexport default function useInvalidPreventRemoveError(\n  state: StackNavigationState<ParamListBase>\n) {\n  const [nextDismissedKey, setNextDismissedKey] = React.useState<string | null>(\n    null\n  );\n\n  const dismissedRouteName = nextDismissedKey\n    ? state.routes.find((route) => route.key === nextDismissedKey)?.name\n    : null;\n\n  React.useEffect(() => {\n    if (dismissedRouteName) {\n      const message =\n        `The screen '${dismissedRouteName}' was removed natively but didn't get removed from JS state. ` +\n        `This can happen if the action was prevented in a 'beforeRemove' listener, which is not fully supported in native-stack.\\n\\n` +\n        `Consider using a 'usePreventRemove' hook with 'headerBackButtonMenuEnabled: false' to prevent users from natively going back multiple screens.`;\n\n      console.error(message);\n    }\n  }, [dismissedRouteName]);\n\n  return { setNextDismissedKey };\n}\n"],"mappings":";;;;;;;AAIA;;;;;;AAEe,SAASA,4BAAT,CACbC,KADa,EAEb;EAAA;;EACA,MAAM,CAACC,gBAAD,EAAmBC,mBAAnB,IAA0CC,KAAK,CAACC,QAAN,CAC9C,IAD8C,CAAhD;EAIA,MAAMC,kBAAkB,GAAGJ,gBAAgB,yBACvCD,KAAK,CAACM,MAAN,CAAaC,IAAb,CAAmBC,KAAD,IAAWA,KAAK,CAACC,GAAN,KAAcR,gBAA3C,CADuC,uDACvC,mBAA8DS,IADvB,GAEvC,IAFJ;EAIAP,KAAK,CAACQ,SAAN,CAAgB,MAAM;IACpB,IAAIN,kBAAJ,EAAwB;MACtB,MAAMO,OAAO,GACV,eAAcP,kBAAmB,+DAAlC,GACC,6HADD,GAEC,gJAHH;MAKAQ,OAAO,CAACC,KAAR,CAAcF,OAAd;IACD;EACF,CATD,EASG,CAACP,kBAAD,CATH;EAWA,OAAO;IAAEH;EAAF,CAAP;AACD"}